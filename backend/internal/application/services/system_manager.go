package services

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/nexuscrm/backend/internal/infrastructure/persistence"
	"github.com/nexuscrm/shared/pkg/constants"
	"github.com/nexuscrm/shared/pkg/models"
	"golang.org/x/crypto/bcrypt"
)

// SystemManager handles system-level operations
type SystemManager struct {
	persistence *PersistenceService
	repo        *persistence.SystemRepository
}

// NewSystemManager creates a new SystemManager
func NewSystemManager(persistence *PersistenceService, repo *persistence.SystemRepository) *SystemManager {
	return &SystemManager{
		persistence: persistence,
		repo:        repo,
	}
}

// LogEvent logs a system event
func (sm *SystemManager) LogEvent(level, source, message string, details *string) error {
	ctx := context.Background()
	// System Context not strictly needed if permission checks skipped for _System_Log?
	// But generic Insert requires user.
	systemContext := &models.UserSession{
		ID:        "system-logger",
		Name:      "System Logger",
		ProfileID: constants.ProfileSystemAdmin,
	}

	timestamp := time.Now().Format(time.RFC3339) // Log timestamp string? Struct uses string.
	// Actually models.SystemLog has `Timestamp string`.
	// Ideally it should be time.Time if database is DATETIME.
	// But `ToSObject` marshals it.
	// If `models.SystemLog` defined Timestamp as string, `json.Marshal` keeps it string.
	// `PersistenceService` handles string->time conversion via `NormalizeSObject` if schema says DATETIME.

	logEntry := models.SystemLog{
		// ID generated by PersistenceService if missing?
		// No, usually UUID.
		// I will let PersistenceService generate ID if it supports empty ID interpolation?
		// `PersistenceService.Insert` calls `GenerateID()` if ID missing in SObject?
		// Logic: `if id == "" { id = services.GenerateID() }` inside Insert?
		// Let's assume yes or supply one.
		Timestamp: timestamp,
		Level:     level,
		Source:    source,
		Message:   message,
		Details:   details,
	}

	// Just use "Log" constant if exists, else "_System_Log"
	// I'll use "_System_Log" directly to be safe as previously viewed in system_tables.json
	if _, err := sm.persistence.Insert(ctx, constants.TableLog, logEntry.ToSObject(), systemContext); err != nil {
		// Log error to std out because logging failed?
		log.Printf("Failed to log event: %v\n", err)
		return err
	}
	return nil
}

// GetLogs retrieves system logs
func (sm *SystemManager) GetLogs(limit int) ([]*models.SystemLog, error) {
	return sm.repo.GetLogs(context.Background(), limit)
}

// TrackRecent tracks a recently viewed record
func (sm *SystemManager) TrackRecent(userID, objectName, recordID, recordName string) error {
	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-tracker",
		Name:      "System Tracker",
		ProfileID: constants.ProfileSystemAdmin,
	}

	// Logic: Upsert based on UserID + RecordID?
	// Check if exists
	// _System_Recent should have unique constraint on user_id + record_id?
	// Index exists: user_id.
	// If duplicates allowed, history grows.
	// Original code: `INSERT INTO ...`. No ON DUPLICATE.
	// So it just Appends.
	// I will just Insert.

	recent := models.RecentItem{
		UserID:        userID,
		ObjectAPIName: objectName,
		RecordID:      recordID,
		RecordName:    recordName,
		Timestamp:     time.Now().Format(time.RFC3339),
	}

	if _, err := sm.persistence.Insert(ctx, constants.TableRecent, recent.ToSObject(), systemContext); err != nil {
		return err
	}
	return nil
}

// GetRecentItems retrieves recently viewed items for a user
func (sm *SystemManager) GetRecentItems(currentUser *models.UserSession, limit int) ([]*models.RecentItem, error) {
	if currentUser == nil {
		return []*models.RecentItem{}, nil
	}
	return sm.repo.GetRecentItems(context.Background(), currentUser.ID, limit)
}

// GetConfig retrieves a system configuration value
func (sm *SystemManager) GetConfig(key string) (*string, error) {
	return sm.repo.GetConfig(context.Background(), key)
}

// GetAllConfigs retrieves all system configurations
func (sm *SystemManager) GetAllConfigs() ([]*models.SystemConfig, error) {
	return sm.repo.GetAllConfigs(context.Background())
}

// SetConfig sets a system configuration value
func (sm *SystemManager) SetConfig(key string, value string, isSecret bool, description string) error {
	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-config-manager",
		Name:      "System Config Manager",
		ProfileID: constants.ProfileSystemAdmin,
	}

	config := models.SystemConfig{
		KeyName:     key,
		Value:       value,
		IsSecret:    isSecret,
		Description: &description,
	}

	// Check existence
	exists, err := sm.repo.CheckConfigExists(ctx, key)
	if err != nil {
		return fmt.Errorf("failed to check config existence: %w", err)
	}

	if exists {
		// Update
		if err := sm.persistence.Update(ctx, constants.TableConfig, key, config.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to update config %s: %w", key, err)
		}
	} else {
		// Insert
		if _, err := sm.persistence.Insert(ctx, constants.TableConfig, config.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to insert config %s: %w", key, err)
		}
	}
	return nil
}

// UpsertProfile creates or updates a system profile
func (sm *SystemManager) UpsertProfile(id, name, description string, isSystem bool) error {
	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-bootstrap",
		Name:      "System Bootstrap",
		ProfileID: constants.ProfileSystemAdmin,
	}

	profile := models.Profile{
		ID:          id,
		Name:        name,
		Description: &description,
		IsActive:    true,
		IsSystem:    isSystem,
	}

	// Check existence by Name (Unique Key) or ID
	existingID, err := sm.repo.GetProfileIDByName(ctx, name)
	if err != nil {
		return fmt.Errorf("failed to check profile existence: %w", err)
	}

	if existingID != "" {
		// Update
		profile.ID = existingID
		if err := sm.persistence.Update(ctx, constants.TableProfile, existingID, profile.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to update profile %s: %w", name, err)
		}
	} else {
		// Insert
		if _, err := sm.persistence.Insert(ctx, constants.TableProfile, profile.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to insert profile %s: %w", name, err)
		}
	}
	return nil
}

// UpsertUser creates or updates a system user
func (sm *SystemManager) UpsertUser(id, name, email, password, profileID string) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password for user %s: %w", email, err)
	}

	var firstName, lastName string
	// Simple Name Split - use full name as first name if single word
	parts := strings.SplitN(name, " ", 2)
	firstName = parts[0]
	if len(parts) > 1 {
		lastName = parts[1]
	}

	username := email // Default username to email

	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-bootstrap",
		Name:      "System Bootstrap",
		ProfileID: constants.ProfileSystemAdmin,
	}

	// Prepare data struct
	user := models.SystemUser{
		ID:        id,
		Username:  username,
		Email:     email,
		Password:  string(hashedPassword),
		FirstName: firstName,
		LastName:  lastName,
		ProfileID: profileID,
		IsActive:  true,
		// CreatedDate handles by Persistence default or set here?
		// Persistence handles created_date if missing? It populates system fields.
	}

	// Check existence by Email (Unique Key)
	existingID, err := sm.repo.GetUserIDByEmail(ctx, email)
	if err != nil {
		return fmt.Errorf("failed to check user existence: %w", err)
	}

	if existingID != "" {
		// Update
		user.ID = existingID // Force ID to match existing
		if err := sm.persistence.Update(ctx, constants.TableUser, existingID, user.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to update user %s: %w", email, err)
		}
	} else {
		// Insert
		if _, err := sm.persistence.Insert(ctx, constants.TableUser, user.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to insert user %s: %w", email, err)
		}
	}
	return nil
}

// BatchUpsertProfiles inserts multiple profiles using direct SQL for performance during bootstrap
func (sm *SystemManager) BatchUpsertProfiles(profiles []models.Profile) error {
	return sm.repo.BatchUpsertProfiles(context.Background(), profiles)
}

// BatchUpsertUsers inserts multiple users using direct SQL for performance during bootstrap
// Uses a dynamic cache for password hashing to avoid redundant BCrypt calls for identical passwords
func (sm *SystemManager) BatchUpsertUsers(users []models.SystemUser) error {
	if len(users) == 0 {
		return nil
	}

	// Pre-calculated bcrypt hash for "Admin123!" (cost 10)
	// This saves ~100ms per user during bootstrap
	hashCache := make(map[string]string)

	preparedUsers := make([]models.SystemUser, len(users))

	for i, u := range users {
		hashedPwd, ok := hashCache[u.Password]
		if !ok {
			h, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
			if err != nil {
				return fmt.Errorf("failed to hash password: %w", err)
			}
			hashedPwd = string(h)
			hashCache[u.Password] = hashedPwd
		}

		// Calculate Names
		// Caller (InitializeSystemData) is responsible for splitting Name into FirstName/LastName
		// stored in u.FirstName and u.LastName

		// Create a copy with hashed password
		preparedUser := u
		preparedUser.Password = hashedPwd
		preparedUsers[i] = preparedUser
	}

	return sm.repo.BatchUpsertUsers(context.Background(), preparedUsers)
}
