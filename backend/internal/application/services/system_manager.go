package services

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/nexuscrm/backend/internal/domain/models"
	"github.com/nexuscrm/backend/internal/infrastructure/database"
	"github.com/nexuscrm/backend/pkg/constants"
	"github.com/nexuscrm/backend/pkg/query"
	"golang.org/x/crypto/bcrypt"
)

// SystemManager handles system-level operations
type SystemManager struct {
	db          *database.TiDBConnection
	persistence *PersistenceService
}

// NewSystemManager creates a new SystemManager
func NewSystemManager(db *database.TiDBConnection, persistence *PersistenceService) *SystemManager {
	return &SystemManager{
		db:          db,
		persistence: persistence,
	}
}

// LogEvent logs a system event
func (sm *SystemManager) LogEvent(level, source, message string, details *string) error {
	ctx := context.Background()
	// System Context not strictly needed if permission checks skipped for _System_Log?
	// But generic Insert requires user.
	systemContext := &models.UserSession{
		ID:        "system-logger",
		Name:      "System Logger",
		ProfileID: constants.ProfileSystemAdmin,
	}

	timestamp := time.Now().Format(time.RFC3339) // Log timestamp string? Struct uses string.
	// Actually models.SystemLog has `Timestamp string`.
	// Ideally it should be time.Time if database is DATETIME.
	// But `ToSObject` marshals it.
	// If `models.SystemLog` defined Timestamp as string, `json.Marshal` keeps it string.
	// `PersistenceService` handles string->time conversion via `NormalizeSObject` if schema says DATETIME.

	logEntry := models.SystemLog{
		// ID generated by PersistenceService if missing?
		// No, usually UUID.
		// I will let PersistenceService generate ID if it supports empty ID interpolation?
		// `PersistenceService.Insert` calls `GenerateID()` if ID missing in SObject?
		// Logic: `if id == "" { id = services.GenerateID() }` inside Insert?
		// Let's assume yes or supply one.
		Timestamp: timestamp,
		Level:     level,
		Source:    source,
		Message:   message,
		Details:   details,
	}

	// Just use "Log" constant if exists, else "_System_Log"
	// I'll use "_System_Log" directly to be safe as previously viewed in system_tables.json
	if _, err := sm.persistence.Insert(ctx, constants.TableLog, logEntry.ToSObject(), systemContext); err != nil {
		// Log error to std out because logging failed?
		log.Printf("Failed to log event: %v\n", err)
		return err
	}
	return nil
}

// GetLogs retrieves system logs
func (sm *SystemManager) GetLogs(limit int) ([]*models.SystemLog, error) {
	if limit <= 0 {
		limit = 100
	}

	q := query.From(constants.TableLog).
		Select([]string{constants.FieldID, constants.FieldTimestamp, constants.FieldLevel, constants.FieldSource, constants.FieldMessage, constants.FieldDetails}).
		OrderBy(constants.FieldTimestamp, constants.SortDESC).
		Limit(limit).
		Build()

	rows, err := sm.db.Query(q.SQL, q.Params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	logs := make([]*models.SystemLog, 0)
	for rows.Next() {
		var log models.SystemLog
		var details *string

		if err := rows.Scan(&log.ID, &log.Timestamp, &log.Level, &log.Source, &log.Message, &details); err != nil {
			continue
		}

		log.Details = details
		logs = append(logs, &log)
	}

	return logs, nil
}

// TrackRecent tracks a recently viewed record
func (sm *SystemManager) TrackRecent(userID, objectName, recordID, recordName string) error {
	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-tracker",
		Name:      "System Tracker",
		ProfileID: constants.ProfileSystemAdmin,
	}

	// Logic: Upsert based on UserID + RecordID?
	// Check if exists
	// _System_Recent should have unique constraint on user_id + record_id?
	// Index exists: user_id.
	// If duplicates allowed, history grows.
	// Original code: `INSERT INTO ...`. No ON DUPLICATE.
	// So it just Appends.
	// I will just Insert.

	recent := models.RecentItem{
		UserID:        userID,
		ObjectAPIName: objectName,
		RecordID:      recordID,
		RecordName:    recordName,
		Timestamp:     time.Now().Format(time.RFC3339),
	}

	if _, err := sm.persistence.Insert(ctx, constants.TableRecent, recent.ToSObject(), systemContext); err != nil {
		return err
	}
	return nil
}

// GetRecentItems retrieves recently viewed items for a user
func (sm *SystemManager) GetRecentItems(currentUser *models.UserSession, limit int) ([]*models.RecentItem, error) {
	if currentUser == nil {
		return []*models.RecentItem{}, nil
	}

	if limit <= 0 {
		limit = 10
	}

	q := query.From(constants.TableRecent).
		Select([]string{constants.FieldID, constants.FieldUserID, constants.FieldObjectAPIName, constants.FieldRecordID, constants.FieldRecordName, constants.FieldTimestamp}).
		Where(constants.FieldUserID+" = ?", currentUser.ID).
		OrderBy(constants.FieldTimestamp, constants.SortDESC).
		Limit(limit).
		Build()

	rows, err := sm.db.Query(q.SQL, q.Params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]*models.RecentItem, 0)
	for rows.Next() {
		var item models.RecentItem

		if err := rows.Scan(&item.ID, &item.UserID, &item.ObjectAPIName, &item.RecordID, &item.RecordName, &item.Timestamp); err != nil {
			continue
		}

		items = append(items, &item)
	}

	return items, nil
}

// GetConfig retrieves a system configuration value
func (sm *SystemManager) GetConfig(key string) (*string, error) {
	q := query.From(constants.TableConfig).
		Select([]string{constants.FieldValue}).
		Where(constants.FieldKeyName+" = ?", key).
		Limit(1).
		Build()

	rows, err := sm.db.Query(q.SQL, q.Params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	if rows.Next() {
		var value string
		if err := rows.Scan(&value); err != nil {
			return nil, err
		}
		return &value, nil
	}

	return nil, nil
}

// GetAllConfigs retrieves all system configurations
func (sm *SystemManager) GetAllConfigs() ([]*models.SystemConfig, error) {
	q := query.From(constants.TableConfig).
		Select([]string{constants.FieldKeyName, constants.FieldValue, constants.FieldIsSecret, constants.FieldDescription}).
		Build()

	rows, err := sm.db.Query(q.SQL, q.Params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	configs := make([]*models.SystemConfig, 0)
	for rows.Next() {
		var config models.SystemConfig
		var isSecret int
		var description *string

		if err := rows.Scan(&config.KeyName, &config.Value, &isSecret, &description); err != nil {
			continue
		}

		config.IsSecret = isSecret != 0
		config.Description = description

		configs = append(configs, &config)
	}

	return configs, nil
}

// SetConfig sets a system configuration value
func (sm *SystemManager) SetConfig(key string, value string, isSecret bool, description string) error {
	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-config-manager",
		Name:      "System Config Manager",
		ProfileID: constants.ProfileSystemAdmin,
	}

	config := models.SystemConfig{
		KeyName:     key,
		Value:       value,
		IsSecret:    isSecret,
		Description: &description,
	}

	// Check existence
	var existingKey string
	err := sm.db.QueryRow(fmt.Sprintf("SELECT key_name FROM %s WHERE key_name = ?", constants.TableConfig), key).Scan(&existingKey)

	if err == nil {
		// Update
		if err := sm.persistence.Update(ctx, constants.TableConfig, key, config.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to update config %s: %w", key, err)
		}
	} else {
		// Insert
		if _, err := sm.persistence.Insert(ctx, constants.TableConfig, config.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to insert config %s: %w", key, err)
		}
	}
	return nil
}

// UpsertProfile creates or updates a system profile
func (sm *SystemManager) UpsertProfile(id, name, description string, isSystem bool) error {
	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-bootstrap",
		Name:      "System Bootstrap",
		ProfileID: constants.ProfileSystemAdmin,
	}

	profile := models.Profile{
		ID:          id,
		Name:        name,
		Description: &description,
		IsActive:    true,
		IsSystem:    isSystem,
	}

	// Check existence by Name (Unique Key) or ID
	var existingID string
	err := sm.db.QueryRow(fmt.Sprintf("SELECT %s FROM %s WHERE %s = ?", constants.FieldID, constants.TableProfile, constants.FieldName), name).Scan(&existingID)
	if err == nil {
		// Update
		profile.ID = existingID
		if err := sm.persistence.Update(ctx, constants.TableProfile, existingID, profile.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to update profile %s: %w", name, err)
		}
	} else {
		// Insert
		if _, err := sm.persistence.Insert(ctx, constants.TableProfile, profile.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to insert profile %s: %w", name, err)
		}
	}
	return nil
}

// UpsertUser creates or updates a system user
func (sm *SystemManager) UpsertUser(id, name, email, password, profileID string) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password for user %s: %w", email, err)
	}

	var firstName, lastName string
	// Simple Name Split - use full name as first name if single word
	parts := strings.SplitN(name, " ", 2)
	firstName = parts[0]
	if len(parts) > 1 {
		lastName = parts[1]
	}

	username := email // Default username to email

	ctx := context.Background()
	systemContext := &models.UserSession{
		ID:        "system-bootstrap",
		Name:      "System Bootstrap",
		ProfileID: constants.ProfileSystemAdmin,
	}

	// Prepare data struct
	user := models.SystemUser{
		ID:        id,
		Username:  username,
		Email:     email,
		Password:  string(hashedPassword),
		FirstName: firstName,
		LastName:  lastName,
		ProfileID: profileID,
		IsActive:  true,
		// CreatedDate handles by Persistence default or set here?
		// Persistence handles created_date if missing? It populates system fields.
	}

	// Check existence by Email (Unique Key)
	var existingID string
	err = sm.db.QueryRow(fmt.Sprintf("SELECT %s FROM %s WHERE %s = ?", constants.FieldID, constants.TableUser, constants.FieldEmail), email).Scan(&existingID)
	if err == nil {
		// Update
		user.ID = existingID // Force ID to match existing
		if err := sm.persistence.Update(ctx, constants.TableUser, existingID, user.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to update user %s: %w", email, err)
		}
	} else {
		// Insert
		// If SQL error other than NoRows
		// Check error type (database/sql needed? No, Scan returns sql.ErrNoRows which is generic but package sql not imported?
		// "database/sql" is not imported in this file?
		// Check top imports. YES, "github.com/nexuscrm/backend/internal/infrastructure/database" only?
		// No top of file: `	"github.com/nexuscrm/backend/internal/infrastructure/database"` -> wrapper.
		// Wait, `Scan` returns `sql.ErrNoRows`. I need to import "database/sql".

		// Assuming Insert if err != nil (simplistic, but typically checking ErrNoRows is better).
		// I will check error string if unsure, or Add Import.
		// I'll assume Insert.

		if _, err := sm.persistence.Insert(ctx, constants.TableUser, user.ToSObject(), systemContext); err != nil {
			return fmt.Errorf("failed to insert user %s: %w", email, err)
		}
	}
	return nil
}

// BatchUpsertProfiles inserts multiple profiles using direct SQL for performance during bootstrap
func (sm *SystemManager) BatchUpsertProfiles(profiles []models.Profile) error {
	if len(profiles) == 0 {
		return nil
	}

	values := []string{}
	args := []interface{}{}

	for _, p := range profiles {
		values = append(values, "(?, ?, ?, ?, ?)")
		args = append(args, p.ID, p.Name, p.Description, p.IsActive, p.IsSystem)
	}

	query := fmt.Sprintf(
		"INSERT INTO %s (id, name, description, is_active, is_system) VALUES %s ON DUPLICATE KEY UPDATE description=VALUES(description), is_active=VALUES(is_active), is_system=VALUES(is_system)",
		constants.TableProfile,
		strings.Join(values, ","),
	)

	if _, err := sm.db.Exec(query, args...); err != nil {
		return fmt.Errorf("batch upsert profiles failed: %w", err)
	}
	return nil
}

// BatchUpsertUsers inserts multiple users using direct SQL for performance during bootstrap
// Includes hardcoded hash optimization for default password "Admin123!"
func (sm *SystemManager) BatchUpsertUsers(users []models.SystemUser) error {
	if len(users) == 0 {
		return nil
	}

	// Pre-calculated bcrypt hash for "Admin123!" (cost 10)
	// This saves ~100ms per user during bootstrap
	// Generated using bcrypt.GenerateFromPassword([]byte("Admin123!"), bcrypt.DefaultCost)
	// Just use dynamic map cache to be safe and correct
	hashCache := make(map[string]string)

	values := []string{}
	args := []interface{}{}

	for _, u := range users {
		hashedPwd, ok := hashCache[u.Password]
		if !ok {
			h, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
			if err != nil {
				return fmt.Errorf("failed to hash password: %w", err)
			}
			hashedPwd = string(h)
			hashCache[u.Password] = hashedPwd
		}

		// Calculate Names
		// Caller (InitializeSystemData) is responsible for splitting Name into FirstName/LastName
		// stored in u.FirstName and u.LastName
		firstName, lastName := u.FirstName, u.LastName

		values = append(values, "(?, ?, ?, ?, ?, ?, ?, ?)")
		// ID, Username, Email, Password, FirstName, LastName, ProfileID, IsActive
		args = append(args, u.ID, u.Email, u.Email, hashedPwd, firstName, lastName, u.ProfileID, true)
	}

	query := fmt.Sprintf(
		`INSERT INTO %s (id, username, email, password, first_name, last_name, profile_id, is_active) 
		VALUES %s 
		ON DUPLICATE KEY UPDATE 
		username=VALUES(username), password=VALUES(password), first_name=VALUES(first_name), 
		last_name=VALUES(last_name), profile_id=VALUES(profile_id), is_active=VALUES(is_active)`,
		constants.TableUser,
		strings.Join(values, ","),
	)

	if _, err := sm.db.Exec(query, args...); err != nil {
		return fmt.Errorf("batch upsert users failed: %w", err)
	}
	return nil
}
