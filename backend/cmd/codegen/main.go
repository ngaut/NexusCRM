// Package main provides a code generator that reads system_tables.json
// and generates Go constants, structs, and TypeScript types.
//
// This ensures a single source of truth for schema definitions.
// If system_tables.json changes, regenerate to get compile-time errors
// for any code using removed/renamed fields.
//
// Usage: go run ./cmd/codegen
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode"
)

// TableDefinition matches the JSON structure in system_tables.json
type TableDefinition struct {
	TableName   string       `json:"tableName"`
	TableType   string       `json:"tableType"`
	Category    string       `json:"category"`
	Description string       `json:"description"`
	Columns     []ColumnDef  `json:"columns"`
	Indices     []IndexDef   `json:"indices,omitempty"`
	ForeignKeys []ForeignKey `json:"foreignKeys,omitempty"`
}

type ColumnDef struct {
	Name          string `json:"name"`
	Type          string `json:"type"`
	PrimaryKey    bool   `json:"primaryKey,omitempty"`
	Nullable      bool   `json:"nullable,omitempty"`
	Unique        bool   `json:"unique,omitempty"`
	Default       string `json:"default,omitempty"`
	AutoIncrement bool   `json:"autoIncrement,omitempty"`
	LogicalType   string `json:"logicalType,omitempty"`
	ReferenceTo   string `json:"referenceTo,omitempty"`
	IsNameField   bool   `json:"isNameField,omitempty"`
}

type IndexDef struct {
	Name    string   `json:"name,omitempty"`
	Columns []string `json:"columns"`
	Unique  bool     `json:"unique,omitempty"`
}

type ForeignKey struct {
	Column     string `json:"column"`
	References string `json:"references"`
	OnDelete   string `json:"onDelete,omitempty"`
	OnUpdate   string `json:"onUpdate,omitempty"`
}

// Generation context
type genContext struct {
	tables    []TableDefinition
	timestamp string
}

func main() {
	// Find project root by looking for system_tables.json
	jsonPath := findSystemTablesJSON()
	if jsonPath == "" {
		log.Fatal("‚ùå Could not find backend/internal/bootstrap/system_tables.json")
	}
	fmt.Printf("üìñ Reading: %s\n", jsonPath)

	// Determine project root from json path
	// jsonPath is like: .../backend/internal/bootstrap/system_tables.json
	projectRoot := filepath.Dir(filepath.Dir(filepath.Dir(filepath.Dir(jsonPath))))

	// Read and parse JSON
	content, err := os.ReadFile(jsonPath)
	if err != nil {
		log.Fatalf("‚ùå Failed to read file: %v", err)
	}

	var tables []TableDefinition
	if err := json.Unmarshal(content, &tables); err != nil {
		log.Fatalf("‚ùå Failed to parse JSON: %v", err)
	}

	fmt.Printf("üìä Total Definitions: %d\n", len(tables))

	ctx := &genContext{
		tables:    tables,
		timestamp: time.Now().Format(time.RFC3339),
	}

	// Generate all outputs
	if err := generateGoTableConstants(ctx, projectRoot); err != nil {
		log.Fatalf("‚ùå Failed to generate table constants: %v", err)
	}

	if err := generateGoFieldConstants(ctx, projectRoot); err != nil {
		log.Fatalf("‚ùå Failed to generate field constants: %v", err)
	}

	if err := generateGoStructs(ctx, projectRoot); err != nil {
		log.Fatalf("‚ùå Failed to generate structs: %v", err)
	}

	if err := generateTypeScript(ctx, projectRoot); err != nil {
		log.Fatalf("‚ùå Failed to generate TypeScript: %v", err)
	}

	if err := generateMCPTypes(ctx, projectRoot); err != nil {
		log.Fatalf("‚ùå Failed to generate MCP types: %v", err)
	}

	fmt.Println("\nüéâ Code generation complete!")
}

func findSystemTablesJSON() string {
	paths := []string{
		"backend/internal/bootstrap/system_tables.json",
		"internal/bootstrap/system_tables.json",
		"../internal/bootstrap/system_tables.json",
	}

	for _, p := range paths {
		if _, err := os.Stat(p); err == nil {
			abs, _ := filepath.Abs(p)
			return abs
		}
	}
	return ""
}

// ============================================================================
// Go Table Constants Generation
// ============================================================================

func generateGoTableConstants(ctx *genContext, projectRoot string) error {
	var sb strings.Builder

	sb.WriteString("// Code generated by cmd/codegen. DO NOT EDIT.\n")
	sb.WriteString("// Source: internal/bootstrap/system_tables.json\n")
	sb.WriteString("// Generated at: " + ctx.timestamp + "\n\n")
	sb.WriteString("package constants\n\n")

	sb.WriteString("// System Table Names\n")
	sb.WriteString("const (\n")

	// Sort tables for deterministic output
	sortedTables := make([]TableDefinition, len(ctx.tables))
	copy(sortedTables, ctx.tables)
	sort.Slice(sortedTables, func(i, j int) bool {
		return sortedTables[i].TableName < sortedTables[j].TableName
	})

	for _, t := range sortedTables {
		constName := tableNameToConstant(t.TableName)
		sb.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, t.TableName))
	}

	sb.WriteString(")\n\n")

	// Generate slice of all tables
	sb.WriteString("// AllSystemTableNames returns all system table names for validation\n")
	sb.WriteString("var AllSystemTableNames = []string{\n")
	for _, t := range sortedTables {
		constName := tableNameToConstant(t.TableName)
		sb.WriteString(fmt.Sprintf("\t%s,\n", constName))
	}
	sb.WriteString("}\n")

	outPath := filepath.Join(projectRoot, "backend", "pkg", "constants", "z_generated_tables.go")
	if err := os.WriteFile(outPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}
	fmt.Printf("‚úÖ Generated: %s (%d bytes)\n", outPath, sb.Len())
	return nil
}

// ============================================================================
// Go Field Constants Generation
// ============================================================================

func generateGoFieldConstants(ctx *genContext, projectRoot string) error {
	var sb strings.Builder

	sb.WriteString("// Code generated by cmd/codegen. DO NOT EDIT.\n")
	sb.WriteString("// Source: internal/bootstrap/system_tables.json\n")
	sb.WriteString("// Generated at: " + ctx.timestamp + "\n\n")
	sb.WriteString("package constants\n\n")

	// Track common fields for backward compatibility
	// These mirror the fields from the original fields.go to maintain compatibility
	commonFields := map[string]string{
		// Primary/Core fields
		"id":           "FieldID",
		"name":         "FieldName",
		"api_name":     "FieldAPIName",
		"label":        "FieldLabel",
		"plural_label": "FieldPluralLabel",
		"description":  "FieldDescription",

		// Audit fields
		"created_date":        "FieldCreatedDate",
		"created_by_id":       "FieldCreatedByID",
		"last_modified_date":  "FieldLastModifiedDate",
		"last_modified_by_id": "FieldLastModifiedByID",
		"owner_id":            "FieldOwnerID",
		"is_deleted":          "FieldIsDeleted",
		"created_by":          "FieldCreatedBy",

		// User fields
		"email":           "FieldEmail",
		"username":        "FieldUsername",
		"password":        "FieldPassword",
		"first_name":      "FieldFirstName",
		"last_name":       "FieldLastName",
		"profile_id":      "FieldProfileID",
		"role_id":         "FieldRoleID",
		"is_active":       "FieldIsActive",
		"last_login_date": "FieldLastLoginDate",

		// Object/Field Metadata
		"type":         "FieldMetaType",
		"object_id":    "FieldObjectID",
		"reference_to": "FieldReferenceTo",
		"is_custom":    "FieldIsCustom",
		"is_system":    "FieldIsSystem",
		"required":     "FieldIsRequired",
		"unique":       "FieldIsUnique",

		// Flow/Action fields
		"trigger_object": "FieldTriggerObject",
		"trigger_type":   "FieldTriggerType",
		"condition":      "FieldCondition",
		"config":         "FieldConfig",
		"status":         "FieldStatus",
		"sort_order":     "FieldSortOrder",

		// Recycle Bin fields
		"record_id":       "FieldRecordID",
		"object_api_name": "FieldObjectAPIName",
		"record_name":     "FieldRecordName",
		"deleted_by":      "FieldDeletedBy",
		"deleted_date":    "FieldDeletedDate",

		// Recent Items fields
		"user_id":   "FieldUserID",
		"timestamp": "FieldTimestamp",

		// Config fields
		"key_name":  "FieldKeyName",
		"value":     "FieldValue",
		"is_secret": "FieldIsSecret",

		// Log fields
		"level":   "FieldLevel",
		"source":  "FieldSource",
		"message": "FieldMessage",
		"details": "FieldDetails",

		// Session fields
		"token":         "FieldToken",
		"expires_at":    "FieldExpiresAt",
		"last_activity": "FieldLastActivity",
		"ip_address":    "FieldIPAddress",
		"user_agent":    "FieldUserAgent",
		"is_revoked":    "FieldIsRevoked",

		// Metadata fields
		"table_name":     "FieldTableName",
		"table_type":     "FieldTableType",
		"category":       "FieldCategory",
		"is_managed":     "FieldIsManaged",
		"schema_version": "FieldSchemaVersion",
	}

	// Generate common fields first (backward compatible)
	sb.WriteString("// Common field names (backward compatible)\n")
	sb.WriteString("const (\n")

	// Sort common fields for deterministic output
	var commonKeys []string
	for k := range commonFields {
		commonKeys = append(commonKeys, k)
	}
	sort.Strings(commonKeys)

	for _, field := range commonKeys {
		constName := commonFields[field]
		sb.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, field))
	}
	sb.WriteString(")\n\n")

	// Generate table-specific field constants
	sortedTables := make([]TableDefinition, len(ctx.tables))
	copy(sortedTables, ctx.tables)
	sort.Slice(sortedTables, func(i, j int) bool {
		return sortedTables[i].TableName < sortedTables[j].TableName
	})

	for _, t := range sortedTables {
		tablePrefix := tableNameToPrefix(t.TableName)
		sb.WriteString(fmt.Sprintf("// %s fields\n", t.TableName))
		sb.WriteString("const (\n")

		// Sort columns for deterministic output
		sortedCols := make([]ColumnDef, len(t.Columns))
		copy(sortedCols, t.Columns)
		sort.Slice(sortedCols, func(i, j int) bool {
			return sortedCols[i].Name < sortedCols[j].Name
		})

		for _, col := range sortedCols {
			constName := fmt.Sprintf("Field%s_%s", tablePrefix, snakeToPascal(col.Name))
			sb.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, col.Name))
		}
		sb.WriteString(")\n\n")
	}

	outPath := filepath.Join(projectRoot, "backend", "pkg", "constants", "z_generated_fields.go")
	if err := os.WriteFile(outPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}
	fmt.Printf("‚úÖ Generated: %s (%d bytes)\n", outPath, sb.Len())
	return nil
}

// ============================================================================
// Go Struct Generation
// ============================================================================

func generateGoStructs(ctx *genContext, projectRoot string) error {
	var sb strings.Builder

	sb.WriteString("// Code generated by cmd/codegen. DO NOT EDIT.\n")
	sb.WriteString("// Source: internal/bootstrap/system_tables.json\n")
	sb.WriteString("// Generated at: " + ctx.timestamp + "\n\n")
	sb.WriteString("//go:generate go run ../../../cmd/codegen\n\n")
	sb.WriteString("package models\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"encoding/json\"\n")
	sb.WriteString("\t\"time\"\n")
	sb.WriteString(")\n\n")

	// Suppress unused import warning
	sb.WriteString("// Ensure imports are used\n")
	sb.WriteString("var (\n")
	sb.WriteString("\t_ json.RawMessage\n")
	sb.WriteString("\t_ time.Time\n")
	sb.WriteString(")\n\n")

	// Sort tables for deterministic output
	sortedTables := make([]TableDefinition, len(ctx.tables))
	copy(sortedTables, ctx.tables)
	sort.Slice(sortedTables, func(i, j int) bool {
		return sortedTables[i].TableName < sortedTables[j].TableName
	})

	for _, t := range sortedTables {
		structName := "Gen" + tableNameToStructName(t.TableName) // Prefix with Gen to avoid conflicts

		// Add description as comment
		if t.Description != "" {
			sb.WriteString(fmt.Sprintf("// %s represents the %s table (generated).\n", structName, t.TableName))
			sb.WriteString(fmt.Sprintf("// %s\n", t.Description))
		} else {
			sb.WriteString(fmt.Sprintf("// %s represents the %s table (generated).\n", structName, t.TableName))
		}

		sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

		for _, col := range t.Columns {
			fieldName := snakeToPascal(col.Name)
			goType := sqlTypeToGoType(col.Type, col.Nullable, col.LogicalType)
			jsonTag := col.Name
			omitEmpty := col.Nullable && !col.PrimaryKey

			// Special handling for password fields - exclude from JSON
			if col.LogicalType == "Password" {
				sb.WriteString(fmt.Sprintf("\t%s %s `json:\"-\"`\n", fieldName, goType))
			} else if omitEmpty {
				sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, jsonTag))
			} else {
				sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag))
			}
		}

		sb.WriteString("}\n\n")

		// Generate GetTableName method (using Get prefix to avoid conflict with TableName field)
		sb.WriteString(fmt.Sprintf("// GetTableName returns the database table name for %s.\n", structName))
		sb.WriteString(fmt.Sprintf("func (%s) GetTableName() string {\n", structName))
		sb.WriteString(fmt.Sprintf("\treturn \"%s\"\n", t.TableName))
		sb.WriteString("}\n\n")
	}

	outPath := filepath.Join(projectRoot, "backend", "internal", "domain", "models", "z_generated.go")
	if err := os.WriteFile(outPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}
	fmt.Printf("‚úÖ Generated: %s (%d bytes)\n", outPath, sb.Len())
	return nil
}

// ============================================================================
// TypeScript Generation
// ============================================================================

func generateTypeScript(ctx *genContext, projectRoot string) error {
	var sb strings.Builder

	sb.WriteString("// Code generated by cmd/codegen. DO NOT EDIT.\n")
	sb.WriteString("// Source: backend/internal/bootstrap/system_tables.json\n")
	sb.WriteString("// Generated at: " + ctx.timestamp + "\n\n")

	// Generate table name constants
	sb.WriteString("// ==================== System Table Names ====================\n\n")
	sb.WriteString("export const SYSTEM_TABLE_NAMES = {\n")

	sortedTables := make([]TableDefinition, len(ctx.tables))
	copy(sortedTables, ctx.tables)
	sort.Slice(sortedTables, func(i, j int) bool {
		return sortedTables[i].TableName < sortedTables[j].TableName
	})

	for _, t := range sortedTables {
		constKey := tableNameToTSKey(t.TableName)
		sb.WriteString(fmt.Sprintf("    %s: '%s',\n", constKey, t.TableName))
	}
	sb.WriteString("} as const;\n\n")
	sb.WriteString("export type SystemTableName = typeof SYSTEM_TABLE_NAMES[keyof typeof SYSTEM_TABLE_NAMES];\n\n")

	// Generate field constants per table
	sb.WriteString("// ==================== Field Constants ====================\n\n")

	for _, t := range sortedTables {
		constName := fmt.Sprintf("FIELDS_%s", tableNameToTSKey(t.TableName))
		sb.WriteString(fmt.Sprintf("export const %s = {\n", constName))

		sortedCols := make([]ColumnDef, len(t.Columns))
		copy(sortedCols, t.Columns)
		sort.Slice(sortedCols, func(i, j int) bool {
			return sortedCols[i].Name < sortedCols[j].Name
		})

		for _, col := range sortedCols {
			key := strings.ToUpper(col.Name)
			sb.WriteString(fmt.Sprintf("    %s: '%s',\n", key, col.Name))
		}
		sb.WriteString("} as const;\n\n")
	}

	// Generate TypeScript interfaces
	sb.WriteString("// ==================== TypeScript Interfaces ====================\n\n")

	for _, t := range sortedTables {
		interfaceName := tableNameToStructName(t.TableName)

		if t.Description != "" {
			sb.WriteString(fmt.Sprintf("/** %s - %s */\n", t.TableName, t.Description))
		}

		sb.WriteString(fmt.Sprintf("export interface %s {\n", interfaceName))

		for _, col := range t.Columns {
			tsType := sqlTypeToTSType(col.Type, col.LogicalType)
			optional := col.Nullable && !col.PrimaryKey

			// Don't expose password fields
			if col.LogicalType == "Password" {
				continue
			}

			if optional {
				sb.WriteString(fmt.Sprintf("    %s?: %s;\n", col.Name, tsType))
			} else {
				sb.WriteString(fmt.Sprintf("    %s: %s;\n", col.Name, tsType))
			}
		}
		sb.WriteString("}\n\n")
	}

	outPath := filepath.Join(projectRoot, "frontend", "src", "generated-schema.ts")
	if err := os.WriteFile(outPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}
	fmt.Printf("‚úÖ Generated: %s (%d bytes)\n", outPath, sb.Len())
	return nil
}

// ============================================================================
// MCP Types Generation
// ============================================================================

func generateMCPTypes(ctx *genContext, projectRoot string) error {
	var sb strings.Builder

	sb.WriteString("// Code generated by cmd/codegen. DO NOT EDIT.\n")
	sb.WriteString("// Source: backend/internal/bootstrap/system_tables.json\n")
	sb.WriteString("// Generated at: " + ctx.timestamp + "\n\n")
	sb.WriteString("package models\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"encoding/json\"\n")
	sb.WriteString("\t\"time\"\n")
	sb.WriteString(")\n\n")

	// Suppress unused import warning
	sb.WriteString("// Ensure imports are used\n")
	sb.WriteString("var (\n")
	sb.WriteString("\t_ json.RawMessage\n")
	sb.WriteString("\t_ time.Time\n")
	sb.WriteString(")\n\n")

	// For MCP, we generate a subset of commonly used types
	// Focus on types that MCP tools actually interact with
	mcpRelevantTables := map[string]bool{
		"_System_User":       true,
		"_System_Object":     true,
		"_System_Field":      true,
		"_System_Dashboard":  true,
		"_System_Profile":    true,
		"_System_Role":       true,
		"_System_Validation": true,
		"_System_Flow":       true,
		"_System_App":        true,
		"_System_Layout":     true,
		"_System_ListView":   true,
	}

	sortedTables := make([]TableDefinition, len(ctx.tables))
	copy(sortedTables, ctx.tables)
	sort.Slice(sortedTables, func(i, j int) bool {
		return sortedTables[i].TableName < sortedTables[j].TableName
	})

	for _, t := range sortedTables {
		if !mcpRelevantTables[t.TableName] {
			continue
		}

		structName := "Gen" + tableNameToStructName(t.TableName) // Prefix to avoid conflicts

		if t.Description != "" {
			sb.WriteString(fmt.Sprintf("// %s represents the %s table (generated).\n", structName, t.TableName))
			sb.WriteString(fmt.Sprintf("// %s\n", t.Description))
		} else {
			sb.WriteString(fmt.Sprintf("// %s represents the %s table (generated).\n", structName, t.TableName))
		}

		sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

		for _, col := range t.Columns {
			// Skip password fields for MCP
			if col.LogicalType == "Password" {
				continue
			}

			fieldName := snakeToPascal(col.Name)
			goType := sqlTypeToGoType(col.Type, col.Nullable, col.LogicalType)
			jsonTag := col.Name
			omitEmpty := col.Nullable && !col.PrimaryKey

			if omitEmpty {
				sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, jsonTag))
			} else {
				sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag))
			}
		}

		sb.WriteString("}\n\n")
	}

	outPath := filepath.Join(projectRoot, "mcp", "pkg", "models", "z_generated.go")
	if err := os.WriteFile(outPath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}
	fmt.Printf("‚úÖ Generated: %s (%d bytes)\n", outPath, sb.Len())
	return nil
}

// ============================================================================
// Helper Functions
// ============================================================================

// tableNameToConstant converts "_System_ApprovalWorkItem" to "TableApprovalWorkItem"
// and "my_table" to "TableMyTable"
func tableNameToConstant(name string) string {
	clean := strings.TrimPrefix(name, "_System_")
	clean = strings.TrimPrefix(clean, "_")
	// Table names are already PascalCase (e.g., ApprovalWorkItem), just prefix with Table
	return "Table" + snakeToPascal(clean)
}

// tableNameToPrefix converts "_System_User" to "SysUser" and "account" to "Account"
func tableNameToPrefix(name string) string {
	if strings.HasPrefix(name, "_System_") {
		clean := strings.TrimPrefix(name, "_System_")
		return "Sys" + snakeToPascal(clean)
	}
	// For standard objects, just use PascalCase name
	return snakeToPascal(name)
}

// tableNameToStructName converts "_System_User" to "SystemUser" and "account" to "Account"
func tableNameToStructName(name string) string {
	if strings.HasPrefix(name, "_System_") {
		clean := strings.TrimPrefix(name, "_")
		clean = strings.ReplaceAll(clean, "_", "")
		// Handle special cases
		clean = strings.ReplaceAll(clean, "System", "System")
		return clean
	}
	return snakeToPascal(name)
}

// tableNameToTSKey converts "_System_User" to "SYSTEM_USER" and "account" to "ACCOUNT"
func tableNameToTSKey(name string) string {
	clean := strings.TrimPrefix(name, "_")
	clean = strings.ReplaceAll(clean, "_", "_")
	return strings.ToUpper(clean)
}

// snakeToPascal converts "created_date" to "CreatedDate"
func snakeToPascal(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	result := strings.Join(parts, "")

	// Handle common abbreviations
	result = strings.ReplaceAll(result, "Id", "ID")
	result = strings.ReplaceAll(result, "Api", "API")
	result = strings.ReplaceAll(result, "Ui", "UI")
	result = strings.ReplaceAll(result, "Url", "URL")
	result = strings.ReplaceAll(result, "Html", "HTML")
	result = strings.ReplaceAll(result, "Json", "JSON")
	result = strings.ReplaceAll(result, "Sql", "SQL")

	return result
}

// sqlTypeToGoType converts SQL types to Go types
func sqlTypeToGoType(sqlType string, nullable bool, logicalType string) string {
	sqlType = strings.ToUpper(sqlType)

	// Handle ENUM types
	if strings.HasPrefix(sqlType, "ENUM") {
		if nullable {
			return "*string"
		}
		return "string"
	}

	// Extract base type (e.g., VARCHAR(255) -> VARCHAR)
	baseType := regexp.MustCompile(`\([^)]*\)`).ReplaceAllString(sqlType, "")
	baseType = strings.TrimSpace(baseType)

	var goType string
	switch baseType {
	case "VARCHAR", "TEXT", "CHAR", "LONGTEXT", "MEDIUMTEXT":
		goType = "string"
	case "INT", "INTEGER", "SMALLINT", "MEDIUMINT":
		goType = "int"
	case "BIGINT":
		goType = "int64"
	case "TINYINT":
		// TINYINT(1) is typically boolean
		if strings.Contains(sqlType, "(1)") {
			goType = "bool"
		} else {
			goType = "int8"
		}
	case "DECIMAL", "NUMERIC", "FLOAT", "DOUBLE":
		goType = "float64"
	case "DATETIME", "TIMESTAMP", "DATE", "TIME":
		goType = "time.Time"
	case "BOOLEAN", "BOOL":
		goType = "bool"
	case "JSON":
		goType = "json.RawMessage"
	case "BLOB", "LONGBLOB", "MEDIUMBLOB":
		goType = "[]byte"
	default:
		goType = "string" // fallback
	}

	// Handle nullable types (use pointers)
	if nullable && goType != "bool" && goType != "json.RawMessage" && goType != "[]byte" {
		return "*" + goType
	}

	return goType
}

// sqlTypeToTSType converts SQL types to TypeScript types
func sqlTypeToTSType(sqlType string, logicalType string) string {
	sqlType = strings.ToUpper(sqlType)

	// Handle ENUM types
	if strings.HasPrefix(sqlType, "ENUM") {
		return "string"
	}

	baseType := regexp.MustCompile(`\([^)]*\)`).ReplaceAllString(sqlType, "")
	baseType = strings.TrimSpace(baseType)

	switch baseType {
	case "VARCHAR", "TEXT", "CHAR", "LONGTEXT", "MEDIUMTEXT":
		return "string"
	case "INT", "INTEGER", "SMALLINT", "MEDIUMINT", "BIGINT", "TINYINT":
		// TINYINT(1) is typically boolean
		if strings.Contains(sqlType, "(1)") && baseType == "TINYINT" {
			return "boolean"
		}
		return "number"
	case "DECIMAL", "NUMERIC", "FLOAT", "DOUBLE":
		return "number"
	case "DATETIME", "TIMESTAMP", "DATE", "TIME":
		return "string" // ISO date strings in JSON
	case "BOOLEAN", "BOOL":
		return "boolean"
	case "JSON":
		return "Record<string, unknown>"
	default:
		return "unknown"
	}
}

// isExportedIdentifier checks if identifier is valid Go exported identifier
func isExportedIdentifier(s string) bool {
	if len(s) == 0 {
		return false
	}
	return unicode.IsUpper(rune(s[0]))
}
