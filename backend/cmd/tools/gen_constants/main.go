package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"time"
)

type SystemConfig struct {
	SystemFields map[string]struct {
		APIName string `json:"apiName"`
	} `json:"systemFields"`
	SystemTables map[string]string `json:"systemTables"`
	Permissions  map[string]struct {
		Value string `json:"value"`
	} `json:"permissions"`
}

func main() {
	// 1. Read the shared system.json
	// Assuming running from project root or finding relative path
	// We'll try a few known locations
	paths := []string{
		"../shared/constants/system.json",          // When running from backend/ cwd
		"shared/constants/system.json",             // When running from root
		"../../../../shared/constants/system.json", // Relative to cmd/tools/gen_constants (fallback)
	}

	var content []byte
	var err error
	for _, p := range paths {
		content, err = os.ReadFile(p)
		if err == nil {
			fmt.Printf("ðŸ“– Found configuration at: %s\n", p)
			break
		}
	}
	if content == nil {
		log.Fatal("âŒ Could not find shared/constants/system.json")
	}

	// 2. Parse JSON
	var config SystemConfig
	if err := json.Unmarshal(content, &config); err != nil {
		log.Fatalf("âŒ Failed to parse JSON: %v", err)
	}

	// 3. Generate Content
	var sb strings.Builder
	sb.WriteString("// Code generated by cmd/tools/gen_constants. DO NOT EDIT.\n")
	sb.WriteString("// Source: shared/constants/system.json\n")
	sb.WriteString(fmt.Sprintf("// Generated at: %s\n\n", time.Now().Format(time.RFC3339)))
	sb.WriteString("package constants\n\n")

	sb.WriteString("const (\n")

	// Tables
	sb.WriteString("\t// System Tables (Generated)\n")

	// Sort keys for deterministic output
	var tableKeys []string
	for k := range config.SystemTables {
		tableKeys = append(tableKeys, k)
	}
	sort.Strings(tableKeys)

	for _, k := range tableKeys {
		val := config.SystemTables[k]
		// Map JSON key directly to Go constant name?
		// JSON: "OBJECT": "_System_Object" -> Go: TableObject = "_System_Object"
		// convert USER_ROLE -> TableUserRole
		goName := toPascalCase("Table_" + k)
		sb.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", goName, val))
	}
	sb.WriteString("\n")

	// Fields
	sb.WriteString("\t// System Fields (Generated)\n")
	var fieldKeys []string
	for k := range config.SystemFields {
		fieldKeys = append(fieldKeys, k)
	}
	sort.Strings(fieldKeys)

	for _, k := range fieldKeys {
		val := config.SystemFields[k].APIName
		// JSON: "CREATED_DATE" -> Go: FieldCreatedDate
		goName := toPascalCase("Field_" + k)
		sb.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", goName, val))
	}
	sb.WriteString("\n")

	// Permissions
	sb.WriteString("\t// Permissions (Generated)\n")
	var permKeys []string
	for k := range config.Permissions {
		permKeys = append(permKeys, k)
	}
	sort.Strings(permKeys)

	for _, k := range permKeys {
		val := config.Permissions[k].Value
		// JSON: "VIEW_ALL" -> Go: PermissionViewAll
		goName := toPascalCase("Permission_" + k)
		sb.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", goName, val))
	}

	sb.WriteString(")\n")

	// 4. Determine output path
	outputPath := "pkg/constants/z_generated.go"
	if _, err := os.Stat("pkg/constants"); os.IsNotExist(err) {
		// Try root-relative path
		outputPath = "backend/pkg/constants/z_generated.go"
		if _, err := os.Stat("backend/pkg/constants"); os.IsNotExist(err) {
			// Fallback for weird CWD (e.g. inside cmd/tools/gen_constants?)
			// But usually we run from root or backend/
			log.Fatal("âŒ Could not find pkg/constants or backend/pkg/constants directory to write to")
		}
	}

	if err := os.WriteFile(outputPath, []byte(sb.String()), 0644); err != nil {
		log.Fatalf("âŒ Failed to write generated file: %v", err)
	}

	fmt.Printf("âœ… Generated %s (%d bytes)\n", outputPath, sb.Len())
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
		}
	}
	// Handle special cases for ID vs Id to match existing style if needed
	// Current style uses ID (FieldID, FieldOwnerID)
	res := strings.Join(parts, "")
	res = strings.ReplaceAll(res, "Id", "ID")
	res = strings.ReplaceAll(res, "Api", "API")
	res = strings.ReplaceAll(res, "Ui", "UI")
	return res
}
